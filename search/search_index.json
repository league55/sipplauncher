{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sipplauncher - automate your VoIP testing Overview \u00b6 Sipplauncher is a Python-3 application. Features: Execute your SIPp test suite with just one command in one VM/container. Easily add SIP traffic testing to your continuous integration pipeline . Run multiple SIPp scenarios at the same time. Highly-configurable. Dynamically creates networking pseudo-interfaces, to which SIPp instances will be bound. Each test execution will generate a .pcap file if desired. Ability to provision and/or clean-up Device Under Test (DUT) using BASH scripts . Embeds DNS server to support DNS mocking for the dynamically assigned IP addresses. Provides information calls per second accumulated (cps) for each scenario Supported transports: UDP TCP TLS . You can either supply your certificate, or Sipplauncher could generate an intermittent one for you. Requirements \u00b6 Supported operating systems \u00b6 CentOS-7 Ubuntu-18.04.3 Other Linux-based distros might suffice as well. However, Sipplauncher is developed and tested only on the above platforms. Therefore, some extra effort might be required to make Sipplauncher work properly on other platforms. Supported network architecture \u00b6 Sipplauncher and DUT should be located within the same physical (or emulated) Ethernet network. Sipplauncher and DUT IP addresses should be located within the same logical IP network Sipplauncher and DUT should have no firewalls between them IPv4 only. IPv6 is not supported Note Sipplauncher dynamically assigns random IP addresses to a host, on which it's launched. The checks are done, to not accidentally use an IP address, which is already assigned to some other machine in the same LAN. However, to avoid impact on your LAN, it's recommended to run Sipplauncher in a private LAN or an emulated environment. Installation \u00b6 Below instructions will guide you on how to perform installation and self-test. Install prerequisites \u00b6 This part is dependant on the selected platform: For CentOS-7: yum install -y wget git make which tcpdump openssl-devel gcc python3-pip wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -ivh epel-release-latest-7.noarch.rpm yum install -y sipp For Ubuntu-18.04.3: apt-get update -qy apt-get install -y git sip-tester tcpdump libssl-dev gcc python3-pip Install Sipplauncher \u00b6 This part is common for all platforms: git clone https://github.com/zaleos/sipplauncher.git -b develop cd sipplauncher make install-reqs make install-all Perform self-testing \u00b6 make install-reqs-test make test All tests should pass without error. Getting started \u00b6 Now let's try running the embedded mock test suite . Let's assume that DUT's IP address is 10.22.22.24 . Go to Sipplauncher directory and run: sipplauncher --dut 10 .22.22.24 --testsuite tmp-testsuite You should see similar output: This means, test suite run has succeded. Individual tests have failed, but this is expected, because these are mock tests, not tied to your DUT. To have a real working test suite for your DUT, you should write it. You can take the embedded mock test suite as an example. To proceed, please see User Guide .","title":"Intro"},{"location":"#overview","text":"Sipplauncher is a Python-3 application. Features: Execute your SIPp test suite with just one command in one VM/container. Easily add SIP traffic testing to your continuous integration pipeline . Run multiple SIPp scenarios at the same time. Highly-configurable. Dynamically creates networking pseudo-interfaces, to which SIPp instances will be bound. Each test execution will generate a .pcap file if desired. Ability to provision and/or clean-up Device Under Test (DUT) using BASH scripts . Embeds DNS server to support DNS mocking for the dynamically assigned IP addresses. Provides information calls per second accumulated (cps) for each scenario Supported transports: UDP TCP TLS . You can either supply your certificate, or Sipplauncher could generate an intermittent one for you.","title":"Overview"},{"location":"#requirements","text":"","title":"Requirements"},{"location":"#supported-operating-systems","text":"CentOS-7 Ubuntu-18.04.3 Other Linux-based distros might suffice as well. However, Sipplauncher is developed and tested only on the above platforms. Therefore, some extra effort might be required to make Sipplauncher work properly on other platforms.","title":"Supported operating systems"},{"location":"#supported-network-architecture","text":"Sipplauncher and DUT should be located within the same physical (or emulated) Ethernet network. Sipplauncher and DUT IP addresses should be located within the same logical IP network Sipplauncher and DUT should have no firewalls between them IPv4 only. IPv6 is not supported Note Sipplauncher dynamically assigns random IP addresses to a host, on which it's launched. The checks are done, to not accidentally use an IP address, which is already assigned to some other machine in the same LAN. However, to avoid impact on your LAN, it's recommended to run Sipplauncher in a private LAN or an emulated environment.","title":"Supported network architecture"},{"location":"#installation","text":"Below instructions will guide you on how to perform installation and self-test.","title":"Installation"},{"location":"#install-prerequisites","text":"This part is dependant on the selected platform: For CentOS-7: yum install -y wget git make which tcpdump openssl-devel gcc python3-pip wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -ivh epel-release-latest-7.noarch.rpm yum install -y sipp For Ubuntu-18.04.3: apt-get update -qy apt-get install -y git sip-tester tcpdump libssl-dev gcc python3-pip","title":"Install prerequisites"},{"location":"#install-sipplauncher","text":"This part is common for all platforms: git clone https://github.com/zaleos/sipplauncher.git -b develop cd sipplauncher make install-reqs make install-all","title":"Install Sipplauncher"},{"location":"#perform-self-testing","text":"make install-reqs-test make test All tests should pass without error.","title":"Perform self-testing"},{"location":"#getting-started","text":"Now let's try running the embedded mock test suite . Let's assume that DUT's IP address is 10.22.22.24 . Go to Sipplauncher directory and run: sipplauncher --dut 10 .22.22.24 --testsuite tmp-testsuite You should see similar output: This means, test suite run has succeded. Individual tests have failed, but this is expected, because these are mock tests, not tied to your DUT. To have a real working test suite for your DUT, you should write it. You can take the embedded mock test suite as an example. To proceed, please see User Guide .","title":"Getting started"},{"location":"contribution_guide/","text":"Getting started \u00b6 Make sure you have a Github account. Making functional changes \u00b6 These are the changes that alter the functional behavior of the product. Workflow : Submit a Github issue if one does not already exist. Make sure you fill in the earliest version that you know has the issue. An issue should contain these sections: Description . Describe the issue including steps to reproduce when it is a bug. Acceptance Criteria . Describe the expected behavior. An issue might contain these sections: Task breakdown . These are the steps the task implementation should be split into. Each step could be merged via separate Merge Request. An issue is not necessary for Trivial changes Create a working branch from the branch you want to base your work on. This is usually the develop branch. Only target release branches if you are certain your fix must be on that branch. Please avoid working directly on the master or develop branch. Please name your branch, using pattern issues/<ID> . Make commits of logical and atomic units to your working branch. Make sure you have added the necessary unit-tests for your changes. Not all cases require adding unit-tests. It's up to you and your experience to decide when to add them. Our reviewers might request you to add them. Check that all unit-tests pass successfully, both new unit-tests and already existing ones. From sipplauncher directory run: make install-all make install-reqs-test make test Add your feature description to documentation, if this is relevant. Documentation is located at sipplauncher/docs folder. You'll be able to preview your documentation changes in the browser location http://<ip_address>:8000/ . For this, run documentation server from sipplauncher directory: make install-reqs-docs make docs_serve Add initial Merge Request of your branch into the target branch. Merge Request should be named WIP: Issue #<issue_number>: <issue_description> . WIP (Work in progress) notifies other developers, that it's too early to review or merge it. Review your Merge Request. Try to put yourself at the place of the reviewer. Will the changes proposed there be easily understandable for the reviewer? Make your Merge Request as small as possible. It's very hard for a reviewer to review a big diff, which contains lots of irrelevant changes. And usually this way new bugs enter the software - they simply leave unnoticed in tons of new code. Therefore, it's essential to make Merge Request as small as possible. To achieve this: Decouple Trivial changes and merge them via separate Merge requests Remove irrelevant changes from Merge Request. We understand that it might be tempting to fix everything as you go. But please don't do this! The changes in your Merge Request should relate only to the description of the Github issue. If you see something bad in adjacent code, please open an issue in Github and work on it later. Remove the WIP: prefix from the Merge Request. Ask the project maintainer (or some other developer working on the project) to review the Merge Request. Please be polite to a reviewer. Remember that reviewing another person's code is usually harder than writing your own. If you have an insurmountable dispute with a reviewer, please add a 3rd person to your discussion to judge. After the Merge Request has been approved by at least 1 person, merge the code. Close the Github issue. Making trivial changes \u00b6 These are the changes that don't alter the functional behavior of the product. They are one of the following: Adding, changing or deleting a comment. Removing unused variables. Changing code formatting (changing text intentation, adding or removing white-spaces, etc). Changing logging content, adding or removing logging. Changing function or class names. Other small changes (several lines of code) that don't change the functional behavior of the product. The workflow for trivial changes contains only several action items from the full workflow : Create a working branch from the branch you want to base your work on. Make commit. Start the first line of a commit with trivial: <issue_description> . Check that all existing unit-tests pass successfully. Add Merge Request of your branch into the target branch. Merge Request should be named trivial: <issue_description> . Merge it. Code review is not required for such changes to be merged.","title":"Contribution Guide"},{"location":"contribution_guide/#getting-started","text":"Make sure you have a Github account.","title":"Getting started"},{"location":"contribution_guide/#making-functional-changes","text":"These are the changes that alter the functional behavior of the product. Workflow : Submit a Github issue if one does not already exist. Make sure you fill in the earliest version that you know has the issue. An issue should contain these sections: Description . Describe the issue including steps to reproduce when it is a bug. Acceptance Criteria . Describe the expected behavior. An issue might contain these sections: Task breakdown . These are the steps the task implementation should be split into. Each step could be merged via separate Merge Request. An issue is not necessary for Trivial changes Create a working branch from the branch you want to base your work on. This is usually the develop branch. Only target release branches if you are certain your fix must be on that branch. Please avoid working directly on the master or develop branch. Please name your branch, using pattern issues/<ID> . Make commits of logical and atomic units to your working branch. Make sure you have added the necessary unit-tests for your changes. Not all cases require adding unit-tests. It's up to you and your experience to decide when to add them. Our reviewers might request you to add them. Check that all unit-tests pass successfully, both new unit-tests and already existing ones. From sipplauncher directory run: make install-all make install-reqs-test make test Add your feature description to documentation, if this is relevant. Documentation is located at sipplauncher/docs folder. You'll be able to preview your documentation changes in the browser location http://<ip_address>:8000/ . For this, run documentation server from sipplauncher directory: make install-reqs-docs make docs_serve Add initial Merge Request of your branch into the target branch. Merge Request should be named WIP: Issue #<issue_number>: <issue_description> . WIP (Work in progress) notifies other developers, that it's too early to review or merge it. Review your Merge Request. Try to put yourself at the place of the reviewer. Will the changes proposed there be easily understandable for the reviewer? Make your Merge Request as small as possible. It's very hard for a reviewer to review a big diff, which contains lots of irrelevant changes. And usually this way new bugs enter the software - they simply leave unnoticed in tons of new code. Therefore, it's essential to make Merge Request as small as possible. To achieve this: Decouple Trivial changes and merge them via separate Merge requests Remove irrelevant changes from Merge Request. We understand that it might be tempting to fix everything as you go. But please don't do this! The changes in your Merge Request should relate only to the description of the Github issue. If you see something bad in adjacent code, please open an issue in Github and work on it later. Remove the WIP: prefix from the Merge Request. Ask the project maintainer (or some other developer working on the project) to review the Merge Request. Please be polite to a reviewer. Remember that reviewing another person's code is usually harder than writing your own. If you have an insurmountable dispute with a reviewer, please add a 3rd person to your discussion to judge. After the Merge Request has been approved by at least 1 person, merge the code. Close the Github issue.","title":"Making functional changes"},{"location":"contribution_guide/#making-trivial-changes","text":"These are the changes that don't alter the functional behavior of the product. They are one of the following: Adding, changing or deleting a comment. Removing unused variables. Changing code formatting (changing text intentation, adding or removing white-spaces, etc). Changing logging content, adding or removing logging. Changing function or class names. Other small changes (several lines of code) that don't change the functional behavior of the product. The workflow for trivial changes contains only several action items from the full workflow : Create a working branch from the branch you want to base your work on. Make commit. Start the first line of a commit with trivial: <issue_description> . Check that all existing unit-tests pass successfully. Add Merge Request of your branch into the target branch. Merge Request should be named trivial: <issue_description> . Merge it. Code review is not required for such changes to be merged.","title":"Making trivial changes"},{"location":"dependencies/","text":"Dependency Version License wheel >=0.33.6 Open Source ( MIT ) ipaddress >=1.0.23 Open Source ( PSF ) pyroute2 >=0.5.7 Open Source ( GPLv2+ and Apache v2 ) scapy >=2.4.3 Open Source ( GPLv2 ) pysipp Git revision b734f39 Open Source ( GPLv2 ) pyOpenSSL >=19.1.0 Open Source ( Apache v2 ) dnslib >=0.9.10 Open Source ( BSD ) dnserver embedded Open Source ( MIT ) sslkeylog embedded Open Source ( GPLv3+ ) mkdocs >=1.0.4 Open Source ( BSD ) mkdocs-material >=4.6.0 Open Source ( MIT ) mkdocs-git-revision-date-plugin >=0.2 Open Source ( MIT ) pytest 3.2.5<= and <=3.3.0 Open Source ( MIT ) flake8 >=3.7.9 Open Source ( MIT ) autopep8 >=1.4.4 Open Source ( MIT ) pytest-mock >=1.6.3 Open Source ( MIT )","title":"Dependencies"},{"location":"developer_guide/","text":"Developer Guide extends User Guide with some information, which is relevant for: Sipplauncher developers and contributors Users, who wish to understand how Sipplauncher works under the hood 1. Initialization \u00b6 Set up the signal handler We need to perform proper cleanup in case if: a user interrupts with CTRL+C Sipplaucnher is terminated with any other signal Otherwise, we'll leave stray \"dummy\" interfaces and partially-configured DUT. Thus, we set up our signal handler. There is a tricky place in signal handling - we can't do much inside the signal handler. We can't even log a message, because sometimes it causes a deadlock. The details of this issue are described in Signals.py . To work around this issue - we set a global variable inside the signal handler. And later we check this variable from the main code. Therefore, we have interruption points , which are deadlock-free. Parse command-line arguments To support Command-line arguments , we use the argparse library. Set up TLS session keys interception To support Decrypting Diffie-Hellman TLS traffic , we include a 3rd-party library sipplauncher/sslkeylog.c . In main.py we set the environment variable LD_PRELOAD , which points to sslkeylog.so . When we launch a child SIPp application, Linux checks this environment variable and preloads sslkeylog.so before running SIPp. This library overwrites some methods in the standard OpenSSL library. This makes possible to intercept and log TLS session keys. Then Sipplauncher passes control to Run.run() , which is defined at Run.py . Run.run() runs in a single thread and performs the following steps: 2. SIPpTest list collection \u00b6 TestPool instance, defined at TestPool.py , collects names of subfolders inside a test suite folder . The names of subfolders are considered the Test names. Then TestPool : Sorts test names in alphabetical order Iterates over the test names. During iterating, each test name is checked. The test is skipped, if: A test name matches the Template folder name. The --pattern-exclude command-line argument is specified and a test name matches it. The --pattern-only command-line argument is specified and a test name doesn't match it. If the test isn't skipped, a SIPpTest is instantiated from a test name and the instance is added to the list. A SIPpTest instance, defined at Test.py , encapsulates everything, needed to execute the test . A list of SIPpTest instances, sorted alphabetically by the test name, is returned to Run.run() . 3. SIPpTest list processing \u00b6 Then the --group command-line argument is considered. Run.run() takes a slice of SIPpTests , which consists of a --group of elements, from the beginning of a SIPpTest list. This slice is considered a SIPpTest run group. Then Run.run() processes a SIPpTest run group. Then Run.run() takes the next slice from the SIPpTest list and processes it . This repeats until all SIPpTests from the list are processed. 4. SIPpTest run group processing \u00b6 SIPpTest run group processing could be divided into stages: consecutive stages Pre-run and Post-run : they're run in the context of the Run.run() thread. concurrent stage Run : it's run in the context of multiple spawned threads and processes. During the stages each SIPpTest transits through states: State colors: color description displayed to a user green state during normal operation yes blue state during normal operation no red state during error yes Here is the order of these stages: 1. Pre-run \u00b6 All SIPpTests in a run group start in the CREATED state. Run.run() consecutively iterates over SIPpTests in a run group. For each of them, SIPpTest.pre_run() method is executed, which: Transits the Test into PREPARING state Assigns dynamic IP addresses The high-level overview is given in Dynamically assigned IP address . For a developer it's worth to add a few notes: The check if the randomly obtained address is already occupied, is performed through the ARP ping . It's used instead of regular ICMP ping because some hosts in LAN might have ICMP replies disabled. And therefore, if we based on ICMP ping, we could cause Ethernet conflicts. The ARP ping is performed using the Scapy library. A new \"dummy\" interface is created for each Test. Dummy interface is named with pattern sipp-<test_run_id> . Then the randomly generated IP addresses are assigned to the \"dummy\" interface. This way we do IP aliasing. We do the \"dummy\" interface approach instead of creating IP aliases via the ip address add <addr> dev eth0 approach for the following reasons: to ease network cleanup: just destroy all interfaces which name matches the sipp-<> pattern to remove the need to specify or calculate network interface on which to create aliases: we rely on the Linux routing system Creates a test run folder Test run folder is created by copying Test folder to location /var/tmp/sipplaucnher/<test_name>/<test_run_id> . Copying is performed using shutil.copytree() . Sets up logging into Test run folder Sipplauncher logging facilities and paths are configured in /usr/local/etc/sipplauncher/sipplauncher.configlog.conf . Static log location is by default defined there as /tmp/sipplauncher.log . We have the following requirements: We need to easily separate the logs of different Test runs. Thus, we want to log the execution of each Test into a Test run folder . The log path should look like /var/tmp/sipplauncher/<test_name>/<test_run_id>/sipplauncher.log , where <test_run_id> is random and isn't known beforehand. Therefore, the Test run log file location can't be static. It should be dynamic. We want to preserve the possibility to configure log message format in /usr/local/etc/sipplauncher/sipplauncher.configlog.conf . To fulfill the above requirements, we implement the logging class sipplauncher.utils.Log.DynamicFileHandler . It should be specified as a logging class for those logs, which need to be stored into a Test run folder . At runtime, we check if the logging class is set to sipplauncher.utils.Log.DynamicFileHandler . And if yes, we supply an actual Test run folder path to sipplauncher.utils.Log.DynamicFileHandler instance. Replaces keywords using the Template Engine A list of files, which need to be processed using the Template engine , is collected: Scripts : result of glob.glob(\"*.sh\") . SIPp scenarios : the files, which match pattern ^(ua[cs])_(ua[0-9]+).xml$ or ^([a-zA-Z0-9]+)_(ua[cs])_(ua[0-9]+).xml$ . DNS zone description file : a dns.txt file. All these files are rendered by the Jinja2 API Template.render() . If the rendering result differs from the original file content - the file is overwritten with the newly rendered content. Generates SSL certificates and keys The process is described here . Python OpenSSL library is used. Adds DNS zone description to the embedded DNS server If the Embedded DNS server hasn't been launched yet, it's launched now. Then a DNS zone description file is added to the embedded DNS server. Python dnslib library is used. Activates pcap sniffing We use scapy.sendrecv.AsyncSniffer to start a new background thread. This thread installs the BPF on all system network interfaces. The BPF matches all traffic regarding Dynamically assigned IP addresses for this particular Test run. The captured traffic is stored in the memory buffer. Runs before.sh If before.sh is present in a Test run folder , we execute it with subprocess.Popen() API. Then we wait for it to finish and check its exit code. Transits the Test into the READY state If we got an error at any of the steps above - the TEST gets transited into the NOT READY state. Sipplauncher doesn't move to the next stages in this case. 2. Run \u00b6 Run.run() iterates over SIPpTests in a run group and for each of them launches the SIPpTest.run() method in a dedicated Python Thread . Then Run.run() waits for threads to finish. SIPpTest.run() method performs following steps: Transits the Test into STARTING state Forks a new PysippProcess PysippProcess is a subclass of the multiprocessing.Process . We need to fork the Process , because we have the requirement to store all the logs, which relate to Test run, in the Test run folder . From this requirement we get the following outcome: Some of the SIPp log locations are not configurable and are logged to a current working directory. Therefore we need to os.chdir() into a Test run folder before running SIPp. os.chdir() changes the current working directory for a whole current process. However, we are going to use it inside the concurrently running Threads . Therefore, this introduces the race condition. Therefore, we need to launch a child Process from a Thread . And then, inside the child Process , call os.chdir() and then run SIPp. This way, we change the working directory inside the child process and avoid the race condition in the parent process. PysippProcess determines the SIPp launch order from SIPp scenario file names. This process is described here . Then PysippProcess launches SIPp instances using the API of the Pysipp library. Reports test result SIPpTest.run() waits for PysippProcess to finish. The test is reported as FAIL if exitcode is non-zero, SUCCESS otherwise. A SIPpTest.run() Thread measures time from its begging and reports the amount of time elapsed. 3. Post-run \u00b6 Post-run performs a rollback of actions, which were done in the Pre-run . The rollback is performed in the opposite order of the Pre-run . Run.run() consecutively iterates over SIPpTests in a run group. For each of them, SIPpTest.post_run() method is executed, which: Transits the Test into the CLEANING state Runs after.sh If after.sh is present in a Test run folder , we execute it with subprocess.Popen() API. Then we wait for it to finish and check its exit code. Deactivates pcap sniffing We invoke scapy.sendrecv.AsyncSniffer.stop() and wait until the background Thread terminates. Then we sort the memory buffer with pcap frames by the frame timestamp. This is needed, because in case if traffic goes through different network interfaces, it could appear in a slightly wrong order inside the memory buffer. Then we store the sorted memory buffer in file sipp-<test_run_id>.pcap in a Test run folder . Removes DNS zone description from the embedded DNS server Removes a test run folder We remove it with shutil.rmtree() , unless the --leave-temp command-line argument was provided. Removes dynamic IP addresses We remove a \"dummy\" pseudo-interface with name sipp-<test_run_id> . Transits the Test into the CLEAN state If we got an error at any of the steps above - the TEST gets transited into the DIRTY state.","title":"Developer Guide"},{"location":"developer_guide/#1-initialization","text":"Set up the signal handler We need to perform proper cleanup in case if: a user interrupts with CTRL+C Sipplaucnher is terminated with any other signal Otherwise, we'll leave stray \"dummy\" interfaces and partially-configured DUT. Thus, we set up our signal handler. There is a tricky place in signal handling - we can't do much inside the signal handler. We can't even log a message, because sometimes it causes a deadlock. The details of this issue are described in Signals.py . To work around this issue - we set a global variable inside the signal handler. And later we check this variable from the main code. Therefore, we have interruption points , which are deadlock-free. Parse command-line arguments To support Command-line arguments , we use the argparse library. Set up TLS session keys interception To support Decrypting Diffie-Hellman TLS traffic , we include a 3rd-party library sipplauncher/sslkeylog.c . In main.py we set the environment variable LD_PRELOAD , which points to sslkeylog.so . When we launch a child SIPp application, Linux checks this environment variable and preloads sslkeylog.so before running SIPp. This library overwrites some methods in the standard OpenSSL library. This makes possible to intercept and log TLS session keys. Then Sipplauncher passes control to Run.run() , which is defined at Run.py . Run.run() runs in a single thread and performs the following steps:","title":"1. Initialization"},{"location":"developer_guide/#2-sipptest-list-collection","text":"TestPool instance, defined at TestPool.py , collects names of subfolders inside a test suite folder . The names of subfolders are considered the Test names. Then TestPool : Sorts test names in alphabetical order Iterates over the test names. During iterating, each test name is checked. The test is skipped, if: A test name matches the Template folder name. The --pattern-exclude command-line argument is specified and a test name matches it. The --pattern-only command-line argument is specified and a test name doesn't match it. If the test isn't skipped, a SIPpTest is instantiated from a test name and the instance is added to the list. A SIPpTest instance, defined at Test.py , encapsulates everything, needed to execute the test . A list of SIPpTest instances, sorted alphabetically by the test name, is returned to Run.run() .","title":"2. SIPpTest list collection"},{"location":"developer_guide/#3-sipptest-list-processing","text":"Then the --group command-line argument is considered. Run.run() takes a slice of SIPpTests , which consists of a --group of elements, from the beginning of a SIPpTest list. This slice is considered a SIPpTest run group. Then Run.run() processes a SIPpTest run group. Then Run.run() takes the next slice from the SIPpTest list and processes it . This repeats until all SIPpTests from the list are processed.","title":"3. SIPpTest list processing"},{"location":"developer_guide/#4-sipptest-run-group-processing","text":"SIPpTest run group processing could be divided into stages: consecutive stages Pre-run and Post-run : they're run in the context of the Run.run() thread. concurrent stage Run : it's run in the context of multiple spawned threads and processes. During the stages each SIPpTest transits through states: State colors: color description displayed to a user green state during normal operation yes blue state during normal operation no red state during error yes Here is the order of these stages:","title":"4. SIPpTest run group processing"},{"location":"developer_guide/#1-pre-run","text":"All SIPpTests in a run group start in the CREATED state. Run.run() consecutively iterates over SIPpTests in a run group. For each of them, SIPpTest.pre_run() method is executed, which: Transits the Test into PREPARING state Assigns dynamic IP addresses The high-level overview is given in Dynamically assigned IP address . For a developer it's worth to add a few notes: The check if the randomly obtained address is already occupied, is performed through the ARP ping . It's used instead of regular ICMP ping because some hosts in LAN might have ICMP replies disabled. And therefore, if we based on ICMP ping, we could cause Ethernet conflicts. The ARP ping is performed using the Scapy library. A new \"dummy\" interface is created for each Test. Dummy interface is named with pattern sipp-<test_run_id> . Then the randomly generated IP addresses are assigned to the \"dummy\" interface. This way we do IP aliasing. We do the \"dummy\" interface approach instead of creating IP aliases via the ip address add <addr> dev eth0 approach for the following reasons: to ease network cleanup: just destroy all interfaces which name matches the sipp-<> pattern to remove the need to specify or calculate network interface on which to create aliases: we rely on the Linux routing system Creates a test run folder Test run folder is created by copying Test folder to location /var/tmp/sipplaucnher/<test_name>/<test_run_id> . Copying is performed using shutil.copytree() . Sets up logging into Test run folder Sipplauncher logging facilities and paths are configured in /usr/local/etc/sipplauncher/sipplauncher.configlog.conf . Static log location is by default defined there as /tmp/sipplauncher.log . We have the following requirements: We need to easily separate the logs of different Test runs. Thus, we want to log the execution of each Test into a Test run folder . The log path should look like /var/tmp/sipplauncher/<test_name>/<test_run_id>/sipplauncher.log , where <test_run_id> is random and isn't known beforehand. Therefore, the Test run log file location can't be static. It should be dynamic. We want to preserve the possibility to configure log message format in /usr/local/etc/sipplauncher/sipplauncher.configlog.conf . To fulfill the above requirements, we implement the logging class sipplauncher.utils.Log.DynamicFileHandler . It should be specified as a logging class for those logs, which need to be stored into a Test run folder . At runtime, we check if the logging class is set to sipplauncher.utils.Log.DynamicFileHandler . And if yes, we supply an actual Test run folder path to sipplauncher.utils.Log.DynamicFileHandler instance. Replaces keywords using the Template Engine A list of files, which need to be processed using the Template engine , is collected: Scripts : result of glob.glob(\"*.sh\") . SIPp scenarios : the files, which match pattern ^(ua[cs])_(ua[0-9]+).xml$ or ^([a-zA-Z0-9]+)_(ua[cs])_(ua[0-9]+).xml$ . DNS zone description file : a dns.txt file. All these files are rendered by the Jinja2 API Template.render() . If the rendering result differs from the original file content - the file is overwritten with the newly rendered content. Generates SSL certificates and keys The process is described here . Python OpenSSL library is used. Adds DNS zone description to the embedded DNS server If the Embedded DNS server hasn't been launched yet, it's launched now. Then a DNS zone description file is added to the embedded DNS server. Python dnslib library is used. Activates pcap sniffing We use scapy.sendrecv.AsyncSniffer to start a new background thread. This thread installs the BPF on all system network interfaces. The BPF matches all traffic regarding Dynamically assigned IP addresses for this particular Test run. The captured traffic is stored in the memory buffer. Runs before.sh If before.sh is present in a Test run folder , we execute it with subprocess.Popen() API. Then we wait for it to finish and check its exit code. Transits the Test into the READY state If we got an error at any of the steps above - the TEST gets transited into the NOT READY state. Sipplauncher doesn't move to the next stages in this case.","title":"1. Pre-run"},{"location":"developer_guide/#2-run","text":"Run.run() iterates over SIPpTests in a run group and for each of them launches the SIPpTest.run() method in a dedicated Python Thread . Then Run.run() waits for threads to finish. SIPpTest.run() method performs following steps: Transits the Test into STARTING state Forks a new PysippProcess PysippProcess is a subclass of the multiprocessing.Process . We need to fork the Process , because we have the requirement to store all the logs, which relate to Test run, in the Test run folder . From this requirement we get the following outcome: Some of the SIPp log locations are not configurable and are logged to a current working directory. Therefore we need to os.chdir() into a Test run folder before running SIPp. os.chdir() changes the current working directory for a whole current process. However, we are going to use it inside the concurrently running Threads . Therefore, this introduces the race condition. Therefore, we need to launch a child Process from a Thread . And then, inside the child Process , call os.chdir() and then run SIPp. This way, we change the working directory inside the child process and avoid the race condition in the parent process. PysippProcess determines the SIPp launch order from SIPp scenario file names. This process is described here . Then PysippProcess launches SIPp instances using the API of the Pysipp library. Reports test result SIPpTest.run() waits for PysippProcess to finish. The test is reported as FAIL if exitcode is non-zero, SUCCESS otherwise. A SIPpTest.run() Thread measures time from its begging and reports the amount of time elapsed.","title":"2. Run"},{"location":"developer_guide/#3-post-run","text":"Post-run performs a rollback of actions, which were done in the Pre-run . The rollback is performed in the opposite order of the Pre-run . Run.run() consecutively iterates over SIPpTests in a run group. For each of them, SIPpTest.post_run() method is executed, which: Transits the Test into the CLEANING state Runs after.sh If after.sh is present in a Test run folder , we execute it with subprocess.Popen() API. Then we wait for it to finish and check its exit code. Deactivates pcap sniffing We invoke scapy.sendrecv.AsyncSniffer.stop() and wait until the background Thread terminates. Then we sort the memory buffer with pcap frames by the frame timestamp. This is needed, because in case if traffic goes through different network interfaces, it could appear in a slightly wrong order inside the memory buffer. Then we store the sorted memory buffer in file sipp-<test_run_id>.pcap in a Test run folder . Removes DNS zone description from the embedded DNS server Removes a test run folder We remove it with shutil.rmtree() , unless the --leave-temp command-line argument was provided. Removes dynamic IP addresses We remove a \"dummy\" pseudo-interface with name sipp-<test_run_id> . Transits the Test into the CLEAN state If we got an error at any of the steps above - the TEST gets transited into the DIRTY state.","title":"3. Post-run"},{"location":"user_guide/","text":"Overview \u00b6 Sipplauncher accepts a path to a test suite , which contains a set of subfolders - tests . The Test subfolder should contain at least one SIPp scenario . The Test subfolder may contain scripts and other files. Scripts and SIPp scenarios may contain references to other UA instance's address in the form ua[0-9].host . Tests may be templated using the Template engine . Test suite folder layout \u00b6 Sipplauncher needs a test suite to run. Test suite location is passed to Sipplauncher with --testsuite command-line option. In case if this option is omitted, Sipplauncher uses a test suite, which is located at <current_working_directory>/tmp-testsuite . To understand the layout required by Sipplauncher, we advise looking at the layout of the embedded mock test suite sipplauncher/tmp-testsuite . The embedded mock test suite is present for the following purposes: demonstrate Sipplauncher test suite layout and features test if Sipplauncher works in your environment ease development and testing of Sipplauncher Here is the layout of the embedded mock test suite: sipplauncher/tmp-testsuite/ \u251c\u2500\u2500 normal-0000 \u2502 \u251c\u2500\u2500 before.sh \u2502 \u251c\u2500\u2500 uac_ua2.xml \u2502 \u251c\u2500\u2500 uas_ua0.xml \u2502 \u2514\u2500\u2500 uas_ua1.xml \u251c\u2500\u2500 normal-0001 \u2502 \u251c\u2500\u2500 after.sh \u2502 \u251c\u2500\u2500 before.sh \u2502 \u251c\u2500\u2500 uac_ua1.xml \u2502 \u2514\u2500\u2500 uas_ua0.xml \u251c\u2500\u2500 options-0000 \u2502 \u2514\u2500\u2500 uac_ua0.xml \u251c\u2500\u2500 options-0001 \u2502 \u251c\u2500\u2500 uac_ua0.xml \u2502 \u251c\u2500\u2500 uac_ua1.xml \u2502 \u2514\u2500\u2500 uac_ua2.xml \u251c\u2500\u2500 TEMPLATES \u2502 \u2514\u2500\u2500 options.jinja2 \u2514\u2500\u2500 users.csv Therefore, a test suite should contain: Tests \u00b6 A test's name is a subfolder name: normal-0000 , normal-0001 , etc. NOTE: Sipplauncher supports a special test for performing global configuration/checks. Default reserved name for this test is GLOBAL but it can be customised via --global-test-folder command-line argument. This test is not allowed to have any SIPp logic but can contain before.sh / after.sh scripts . Global before.sh will run once before the very first test and global after.sh will run once after the last test. Each test folder contains all the information needed for a test to run: SIPp scenarios \u00b6 These are files named uac_ua2.xml , uas_ua0.xml , etc. A scenario file name defines a launch order and role of a SIPp instance. A scenario file name should match one of the regex patterns: ^(ua[cs])_(ua[0-9]+).xml$ . ^([a-zA-Z0-9]+)_(ua[cs])_(ua[0-9]+).xml$ A scenario file name contains several parts: ^([a-zA-Z0-9]+) optional part. This part defines an ID of a run group , in which the scenario will be run. This part divides all the scenarios into groups and determines the order of running these groups. Here are the rules: Scenarios from the same run group are run concurrently. Different run groups are run consecutively, ordered by the run group ID value. If this part is absent, it's assumed that the scenario's run group ID is \"\" (empty string). For example: normal-0000 \u251c\u2500\u2500 uac_ua0.xml \u2514\u2500\u2500 uas_ua1.xml Here, it's assumed that all scenarios belong to the same run group ID \"\". And therefore, all these scenarios are run concurrently. Here is the example of a more complex Test folder layout: normal-0001 \u251c\u2500\u2500 part0_uac_ua0.xml \u251c\u2500\u2500 part0_uas_ua1.xml \u2514\u2500\u2500 part1_uac_ua0.xml Here, Sipplauncher will determine 2 run groups: part0 part1 Then, Sipplauncher will run concurrently part0_uac_ua0.xml and part0_uas_ua1.xml and wait for them to finish. If any of these scenarios fail, test execution stops. Otherwise, Sipplauncher then runs part1_uac_ua0.xml . ua0 preserves the same dynamically assigned IP address when running both run groups. (ua[cs]) mandatory part. This part defines the order of launching SIPp instances inside a run group . uas scenarios are launched before uac scenarios. ua[0-9] mandatory part. This part defines an instance name inside a SIPp instance group. A SIPp instance in a group can refer to other SIPp instances in the same group using ua[0-9].host keywords in its scenario file. For example, we have files named uac_ua2.xml and uas_ua0.xml in a test folder. uac_ua2.xml may refer to SIPp instance, which runs uas_ua0.xml , using ua0.host keyword. This is possible due to the Dynamic IP address assignment and Keyword replacement . First, dynamic IP addresses are allocated and assigned. Then, the Template engine replaces ua[0-9].host keywords with real IP addresses of SIPp instances. There shouldn't be duplicates of the SIPp instance name in the same run group . Here are the examples: Duplicate SIPp instance names are disallowed within the same default run group : normal-0000 \u251c\u2500\u2500 uac_ua0.xml \u2514\u2500\u2500 uas_ua0.xml Duplicate SIPp instance names are disallowed within the same run group part0 : normal-0001 \u251c\u2500\u2500 part0_uac_ua0.xml \u2514\u2500\u2500 part0_uas_ua0.xml Duplicate SIPp instance names are allowed within different run groups part0 and part1 : normal-0002 \u251c\u2500\u2500 part0_uac_ua0.xml \u2514\u2500\u2500 part1_uas_ua0.xml SIPp instance preserves the same dynamically assigned IP address when running both run groups. Therefore, in the above example, ua0 will preserve its IP when running in group part0 and part1 . Scripts \u00b6 Files, which have .sh extension, are considered the scripts. There are 2 predefined script names, which are automatically run by Sipplauncher if present: before.sh is run before running the SIPp instance group. after.sh is run after running the SIPp instance group. These scripts could be used to provision a DUT with some configuration, which is needed for a test to pass. All other scripts aren't run automatically by Sipplauncher but could be run from elsewhere. For example, from the SIPp scenario . When preparing a test to run, the keywords inside all test's scripts are replaced . If before.sh exits with non-zero exit code, a test execution stops. If either before.sh or after.sh exits with non-zero exit code, the test is considered failed. NOTE: Special purpose global before.sh / after.sh scripts are supported . DNS zone description file \u00b6 A file named dns.txt is considered the DNS zone description file. When preparing a test to run, the keywords inside this file are replaced . Then the contents of this file are added to the Embedded DNS server . After the test is finished, the file is removed from the Embedded DNS server . The example of a dns.txt contents: ep1.example.com A {{ '{{' }} ua1.host {{ '}}' }} # UDP SRV records _sip._udp.example.com. SRV [ 10 , 60 , 5060 , \"ep1.example.com.\" ] # TCP SRV records _sip._tcp.example.com. SRV [ 10 , 60 , 5060 , \"ep1.example.com.\" ] # TLS SRV records _sip._tls.example.com. SRV [ 10 , 60 , 5061 , \"ep1.example.com.\" ] # SIPS SRV records _sips._tcp.example.com. SRV [ 10 , 60 , 5061 , \"ep1.example.com.\" ] Injection file \u00b6 Injection file is passed to Sipplauncher with --sipp-info-file command-line option. Sippluncher, in turn, passes this file to SIPp with -inf option. SIPp reads a line from this file per each new call and replaces keywords in a scenario. In case if this option is omitted, Sipplauncher uses pre-defined location <testsuite_folder>/users.csv . If there is no file at this location, an injection file isn't used. In the embedded mock test suite , the injection file is sipplauncher/tmp-testsuite/users.csv . Templates \u00b6 A template folder contains templates, which could be re-used by Tests to avoid code duplication. A good design pattern is to extract an often-used code of a test into a template and then re-use that template. Template expansion is performed by the Template engine . A template folder is passed to Sipplauncher with --template-folder command-line option. In case if this option is omitted, Sipplauncher uses pre-defined location <testsuite_folder>/TEMPLATES . If there is no folder at this location, templates aren't used. In the embedded mock test suite , the template folder is sipplauncher/tmp-testsuite/TEMPLATES . Command-line arguments \u00b6 Run this to see all available arguments: sipplauncher -h Mandatory arguments \u00b6 argument name argument value description --dut DUT Device under test IP address --testsuite TESTSUITE Path to a Test suite . Default: <current_working_directory>/tmp-testsuite . Optional arguments \u00b6 argument name argument value description -h, --help Show help message and exit --template-folder TEMPLATE_FOLDER Path to a folder with templates . Default: <testsuite>/TEMPLATES . --pattern-exclude PATTERN_EXCLUDE Regular expression to exclude tests. If used with --pattern-only arg, and a test name matches both, the test is excluded. Example: --pattern-exclude options --pattern-exclude '.*_dns' --pattern-exclude '.*_tls' . --pattern-only PATTERN_ONLY Regular expression to specify the only tests which should be run. If used with --pattern-exclude arg, and a test name matches both, the test is excluded. Example: --pattern-only options --pattern-only '.*_dns' --pattern-only '.*_tls' . --network-mask NETWORK_MASK Network mask, which is used for Dynamic IP address assignment . Default: 24 . --group GROUP Number of SIPp tests to be run at the same time. Default: 1 . Please see the example . --group-pause GROUP_PAUSE Pause between group executions. Default: 0.8 . --group-stop-first-fail Stops after any test of the group fails. --random Selects randomly tests from the test pool (instead of alphabetical consecutive ordering). --loop Repeat tests in an endless loop (until interrupted by CTRL+C). It could be used together with group-stop-first-fail arg in order to repeat some test endlessly until it fails, to reproduce some rare issue. --dry-run Dry run, simulates an execution without actual SIPp scenarios launch. --fail-expected OK if the execution fails. --leave-temp Don't remove test run folder after the test has finished. By default, a test run folder is removed after the test has finished. --keyword-replacement-values KEYWORD_REPLACEMENT_VALUES Custom keyword values in JSON object format to be used by the Template engine to replace values in Templated files . Example: --keyword-replacement-values '{ \"ua1_username\": \"test1\", \"ua2_username\": \"test2\", \"some_url\": \"http://10.22.22.24:8080\" }' . --no-pcap Disable capturing to pcap files. --tls-ca-root-cert TLS_CA_ROOT_CERT TLS CA root certificate file (.pem format). It must be used together with tls-ca-root-key arg. --tls-ca-root-key TLS_CA_ROOT_KEY TLS CA root key file (.pem format). It must be used together with tls-ca-root-key arg. --sipp-transport One of: u1, un, ui, t1, tn, l1, ln SIPp -t param. The default is l1 , if TLS usage is auto-detected. Otherwise, it's u1 . TLS usage is auto-detected if any tls-related option is used. --sipp-info-file SIPP_INFO_FILE SIPp -inf argument. Used to specify an Injection file . --sipp-call-rate SIPP_CALL_RATE Calls per seconds, SIPp -r param. Be aware, that --sipp-concurrent-calls-limit could be hit before call rate. --sipp-max-calls SIPP_MAX_CALLS Amount of calls to perform. SIPp -m argument. --sipp-recv-timeout SIPP_RECV_TIMEOUT SIPp -recv_timeout argument. --sipp-tls-version One of: 1.0, 1.1, 1.2 SIPp -tls_version argument. Please see TLS . --sipp-concurrent-calls-limit Number Maximum number of simultaneous calls. Default: 1. SIPp -l param. --default_behaviors DEFAULT_BEHAVIORS SIPp -default_behaviors argument. --global-test-folder GLOBAL_TEST_FOLDER Path to the folder which contains global provisioning or checking scripts. Default: GLOBAL . Common usage examples \u00b6 Run all tests consecutively \u00b6 sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> Run all tests with concurrent grouping by 3 tests \u00b6 Split all tests into concurrent groups of 3 tests in each group. Next, run all groups consecutively. 3 tests inside a group are run concurrently. sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --group 3 Run a single test \u00b6 Let's assume, test suite contains a test named normal-0000 . To run only this test: sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --pattern-only normal-0000 Run a single test concurrently (SIPp concurrency) \u00b6 Let's assume, test suite contains a test named normal-0000 . To run this test concurrently in the scope of a single sipplauncher test run (utilising SIPp's capability to generate multiple calls from a single test definition): sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --pattern-only normal-0000 --sipp-max-calls 3 --sipp-call-rate 3 --sipp-concurrent-calls-limit 3 Run a single test concurrently (sipplauncher concurrency) \u00b6 Let's assume, test suite contains a test named normal-0000 . To run this test concurrently as number of unique sipplauncher test runs: sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --pattern-only normal-0000 --group 3 --total 3 Test run folder \u00b6 Before executing a test, Sipplauncher copies its content to a temporary test folder. Default location of test run folder is /var/tmp/sipplauncher/<test_name>/<test_run_id> . test_name matches test folder name from Test suite folder layout . test_run_id is assigned dynamically for each test run and is seen in test result output . Then Sipplauncher replaces keywords in the Templated files . Then Sipplauncher launches SIPp instances in the working directory of a Test run folder . After the test has finished, Test run folder contains: scripts and SIPp scenarios , which were run during the test DNS zone description file , which was served by the Embedded DNS server all log files generated TLS certificates, private keys and session keys pcap file By default, the Test run folder is deleted after the test has finished. To change this behavior, please use --leave-temp command-line argument. Template engine \u00b6 Sipplauncher uses Jinja2 as a template engine. Therefore, you can use Jinja2 syntax when defining the Templated files . A good example of the approach can be found in the embedded mock test suite . Templates could be placed either into a Test folder or in the Templates folder. Both these locations are searched when Jinja2 imports a template into a test. Templated files \u00b6 The Template engine processes the following files: scripts SIPp scenarios DNS zone description file Keyword replacement \u00b6 The Template engine is also responsible for replacing keywords in the Templated files . Keywords could be either internal or supplied using --keyword-replacement-values command-line argument. To define a keyword in a script or SIPp scenario , you should use {{ '{{' }}keyword{{ '}}' }} syntax. Internal keywords \u00b6 keyword desription dut.host the value, passed via --dut command-line argument. test.name the Test subfolder name. test.run_id the Test random run ID (size 6). test.run_id_number another random id (size 12) composed only of integers/digits. ua[0-9].host Dynamically assigned IP address for the test's SIPp instance ua[0-9] . Dynamic IP address assignment \u00b6 Sipplauncher assigns random IP addresses from a DUT IP network before running each test. Sipplauncher takes a DUT IP address, which is supplied via --dut command-line argument. Then it applies a network mask, which is supplied via --network-mask command-line argument, to the DUT IP address. The result is considered the DUT network. Then Sipplauncher randomly allocates IP addresses from the DUT network. The allocated address is then checked to be not yet assigned to another machine in the same LAN. Then the address is assigned to a machine, which runs Sipplauncher. The number of assigned IP addresses corresponds to the number of SIPp scenarios in a test . After the test has finished, the allocated IP addresses are deleted. Embedded DNS server \u00b6 Sipplauncher has the DNS server inside. This makes possible to mock DNS names resolution for a DUT. Thus, if requested, Sipplauncher adds dynamically assigned IP addresses to the embedded DNS server. And then SIPp scenarios might use domain names instead of IP addresses. This allows testing how a DUT works with regards to the DNS name resolution. Of course, the DUT should be configured to use Sipplauncher's DNS service instead of regular DNS servers. Usually, this requires patching the DUT's /etc/resolve.conf like this: search example.com nameserver 10 .22.22.22 Here 10.22.22.22 - is the IP address of Sipplauncher's VM. Sipplauncher launches the DNS service on UDP port 53 , if at least one Test has DNS zone description file in it. When a Test is prepared , a DNS zone description file is added to the DNS server. When a Test is cleaned , a DNS zone description file is removed from the DNS server. The DNS server has only a single instance. It's shared among all the Tests . Therefore, to support concurrent test execution (see --group command-line argument), tests should avoid defining overlapping DNS zone information. For example, TestA defines such entry in its dns.txt : ep1.example.com A {{ '{{' }}ua1.host{{ '}}' }} And TestB defines the same entry in its dns.txt : ep1.example.com A {{ '{{' }}ua2.host{{ '}}' }} Then a single DNS server instance will be configured this way: ep1.example.com A 10.22.22.123 ep1.example.com A 10.22.22.210 Therefore, information for ep1.example.com is overlapping. This will cause undefined behavior when a DUT attempts to resolve ep1.example.com . Note The same issue will occur if TestB defines an entry in its dns.txt this way: ep1.example.com A {{ '{{' }}ua1.host{{ '}}' }} Due to the Dynamic IP address assignment , {{ '{{' }}ua1.host{{ '}}' }} will be replaced with different IP addresses for TestA and TestB. And thus the collision will occur. TLS \u00b6 Sipplauncher supports SIP TLS endpoints. For TLS to work on a UAS SIP endpoint, SSL certificate and private key should be provided to a UAS instance. Sipplauncher by default generates ephemeral SSL certificate and private key for each UAS. And launches UAS using this SSL certificate and private key. However, in this case, security issues regarding using certificates, issued by not-trusted CA, are likely to arise on a DUT UAC side, when the DUT as UAC tries to connect to such a UAS. To overcome this issue, --tls-ca-root-cert and --tls-ca-root-key Sipplauncher arguments could be handy. If these arguments were provided, Sipplauncher signs a generated SSL certificate and private key with supplied CA root certificate and private key. A DUT should be configured to trust this CA. Then a connection is established without security issues. The generated SSL certificates and private keys are saved to a Test run folder . TLS packet exchange is stored in a .pcap file and could be decrypted . Pcap capturing \u00b6 By default, Sipplauncher captures all packets, which have dynamically assigned IP addresses as either src or dst . Packet exchange is captured into a .pcap file, which could be opened with the Wireshark application. Pcap file is named sipp-<test_run_id>.pcap and is stored in a Test run folder . You can disable Pcap capturing with --no-pcap command-line argument. Decrypting TLS traffic \u00b6 Usually, it's easy to decrypt SSL packet exchange, if you have SSL private key. However, this is not the case for the Diffie-Hellman encryption algorithm. This algorithm uses per-session dynamic keys. Sipplauncher helps to decrypt even Diffie-Hellman-encoded packet exchange. For this, Sipplauncher logs per-session dynamic keys into tls_premaster_keys.txt file in a Test run folder . Then this file could be used to decrypt the packet exchange in Wireshark. You can go to Edit \u2192 Preferences \u2192 Protocols \u2192 SSL and choose tls_premaster_keys.txt in (Pre)-Master-Secret log filename field: Wireshark SSL preferences To enable this feature, you should install Sipplauncher from the source . Log files \u00b6 Logging facility is controlled via /usr/local/etc/sipplauncher/sipplauncher.configlog.conf . By default, Sipplauncher logs to following files: /tmp/sipplauncher.log - general log file. /var/tmp/sipplauncher/<test_name>/<test_run_id>/sipplauncher.log - log, that contains information regarding execution of test test_name . /var/tmp/sipplauncher/<test_name>/<test_run_id>/pysipp.launch.log - log, that contains information regarding running SIPp instances of test test_name . /var/tmp/sipplauncher/<test_name>/<test_run_id>/tls_premaster_keys.txt - log of captured TLS Pre-master keys . /var/tmp/sipplauncher/<test_name>/<test_run_id>/ua[0-9].. - varios SIPp scenario ua[0-9] logs, which were produced by SIPp.","title":"User Guide"},{"location":"user_guide/#overview","text":"Sipplauncher accepts a path to a test suite , which contains a set of subfolders - tests . The Test subfolder should contain at least one SIPp scenario . The Test subfolder may contain scripts and other files. Scripts and SIPp scenarios may contain references to other UA instance's address in the form ua[0-9].host . Tests may be templated using the Template engine .","title":"Overview"},{"location":"user_guide/#test-suite-folder-layout","text":"Sipplauncher needs a test suite to run. Test suite location is passed to Sipplauncher with --testsuite command-line option. In case if this option is omitted, Sipplauncher uses a test suite, which is located at <current_working_directory>/tmp-testsuite . To understand the layout required by Sipplauncher, we advise looking at the layout of the embedded mock test suite sipplauncher/tmp-testsuite . The embedded mock test suite is present for the following purposes: demonstrate Sipplauncher test suite layout and features test if Sipplauncher works in your environment ease development and testing of Sipplauncher Here is the layout of the embedded mock test suite: sipplauncher/tmp-testsuite/ \u251c\u2500\u2500 normal-0000 \u2502 \u251c\u2500\u2500 before.sh \u2502 \u251c\u2500\u2500 uac_ua2.xml \u2502 \u251c\u2500\u2500 uas_ua0.xml \u2502 \u2514\u2500\u2500 uas_ua1.xml \u251c\u2500\u2500 normal-0001 \u2502 \u251c\u2500\u2500 after.sh \u2502 \u251c\u2500\u2500 before.sh \u2502 \u251c\u2500\u2500 uac_ua1.xml \u2502 \u2514\u2500\u2500 uas_ua0.xml \u251c\u2500\u2500 options-0000 \u2502 \u2514\u2500\u2500 uac_ua0.xml \u251c\u2500\u2500 options-0001 \u2502 \u251c\u2500\u2500 uac_ua0.xml \u2502 \u251c\u2500\u2500 uac_ua1.xml \u2502 \u2514\u2500\u2500 uac_ua2.xml \u251c\u2500\u2500 TEMPLATES \u2502 \u2514\u2500\u2500 options.jinja2 \u2514\u2500\u2500 users.csv Therefore, a test suite should contain:","title":"Test suite folder layout"},{"location":"user_guide/#tests","text":"A test's name is a subfolder name: normal-0000 , normal-0001 , etc. NOTE: Sipplauncher supports a special test for performing global configuration/checks. Default reserved name for this test is GLOBAL but it can be customised via --global-test-folder command-line argument. This test is not allowed to have any SIPp logic but can contain before.sh / after.sh scripts . Global before.sh will run once before the very first test and global after.sh will run once after the last test. Each test folder contains all the information needed for a test to run:","title":"Tests"},{"location":"user_guide/#sipp-scenarios","text":"These are files named uac_ua2.xml , uas_ua0.xml , etc. A scenario file name defines a launch order and role of a SIPp instance. A scenario file name should match one of the regex patterns: ^(ua[cs])_(ua[0-9]+).xml$ . ^([a-zA-Z0-9]+)_(ua[cs])_(ua[0-9]+).xml$ A scenario file name contains several parts: ^([a-zA-Z0-9]+) optional part. This part defines an ID of a run group , in which the scenario will be run. This part divides all the scenarios into groups and determines the order of running these groups. Here are the rules: Scenarios from the same run group are run concurrently. Different run groups are run consecutively, ordered by the run group ID value. If this part is absent, it's assumed that the scenario's run group ID is \"\" (empty string). For example: normal-0000 \u251c\u2500\u2500 uac_ua0.xml \u2514\u2500\u2500 uas_ua1.xml Here, it's assumed that all scenarios belong to the same run group ID \"\". And therefore, all these scenarios are run concurrently. Here is the example of a more complex Test folder layout: normal-0001 \u251c\u2500\u2500 part0_uac_ua0.xml \u251c\u2500\u2500 part0_uas_ua1.xml \u2514\u2500\u2500 part1_uac_ua0.xml Here, Sipplauncher will determine 2 run groups: part0 part1 Then, Sipplauncher will run concurrently part0_uac_ua0.xml and part0_uas_ua1.xml and wait for them to finish. If any of these scenarios fail, test execution stops. Otherwise, Sipplauncher then runs part1_uac_ua0.xml . ua0 preserves the same dynamically assigned IP address when running both run groups. (ua[cs]) mandatory part. This part defines the order of launching SIPp instances inside a run group . uas scenarios are launched before uac scenarios. ua[0-9] mandatory part. This part defines an instance name inside a SIPp instance group. A SIPp instance in a group can refer to other SIPp instances in the same group using ua[0-9].host keywords in its scenario file. For example, we have files named uac_ua2.xml and uas_ua0.xml in a test folder. uac_ua2.xml may refer to SIPp instance, which runs uas_ua0.xml , using ua0.host keyword. This is possible due to the Dynamic IP address assignment and Keyword replacement . First, dynamic IP addresses are allocated and assigned. Then, the Template engine replaces ua[0-9].host keywords with real IP addresses of SIPp instances. There shouldn't be duplicates of the SIPp instance name in the same run group . Here are the examples: Duplicate SIPp instance names are disallowed within the same default run group : normal-0000 \u251c\u2500\u2500 uac_ua0.xml \u2514\u2500\u2500 uas_ua0.xml Duplicate SIPp instance names are disallowed within the same run group part0 : normal-0001 \u251c\u2500\u2500 part0_uac_ua0.xml \u2514\u2500\u2500 part0_uas_ua0.xml Duplicate SIPp instance names are allowed within different run groups part0 and part1 : normal-0002 \u251c\u2500\u2500 part0_uac_ua0.xml \u2514\u2500\u2500 part1_uas_ua0.xml SIPp instance preserves the same dynamically assigned IP address when running both run groups. Therefore, in the above example, ua0 will preserve its IP when running in group part0 and part1 .","title":"SIPp scenarios"},{"location":"user_guide/#scripts","text":"Files, which have .sh extension, are considered the scripts. There are 2 predefined script names, which are automatically run by Sipplauncher if present: before.sh is run before running the SIPp instance group. after.sh is run after running the SIPp instance group. These scripts could be used to provision a DUT with some configuration, which is needed for a test to pass. All other scripts aren't run automatically by Sipplauncher but could be run from elsewhere. For example, from the SIPp scenario . When preparing a test to run, the keywords inside all test's scripts are replaced . If before.sh exits with non-zero exit code, a test execution stops. If either before.sh or after.sh exits with non-zero exit code, the test is considered failed. NOTE: Special purpose global before.sh / after.sh scripts are supported .","title":"Scripts"},{"location":"user_guide/#dns-zone-description-file","text":"A file named dns.txt is considered the DNS zone description file. When preparing a test to run, the keywords inside this file are replaced . Then the contents of this file are added to the Embedded DNS server . After the test is finished, the file is removed from the Embedded DNS server . The example of a dns.txt contents: ep1.example.com A {{ '{{' }} ua1.host {{ '}}' }} # UDP SRV records _sip._udp.example.com. SRV [ 10 , 60 , 5060 , \"ep1.example.com.\" ] # TCP SRV records _sip._tcp.example.com. SRV [ 10 , 60 , 5060 , \"ep1.example.com.\" ] # TLS SRV records _sip._tls.example.com. SRV [ 10 , 60 , 5061 , \"ep1.example.com.\" ] # SIPS SRV records _sips._tcp.example.com. SRV [ 10 , 60 , 5061 , \"ep1.example.com.\" ]","title":"DNS zone description file"},{"location":"user_guide/#injection-file","text":"Injection file is passed to Sipplauncher with --sipp-info-file command-line option. Sippluncher, in turn, passes this file to SIPp with -inf option. SIPp reads a line from this file per each new call and replaces keywords in a scenario. In case if this option is omitted, Sipplauncher uses pre-defined location <testsuite_folder>/users.csv . If there is no file at this location, an injection file isn't used. In the embedded mock test suite , the injection file is sipplauncher/tmp-testsuite/users.csv .","title":"Injection file"},{"location":"user_guide/#templates","text":"A template folder contains templates, which could be re-used by Tests to avoid code duplication. A good design pattern is to extract an often-used code of a test into a template and then re-use that template. Template expansion is performed by the Template engine . A template folder is passed to Sipplauncher with --template-folder command-line option. In case if this option is omitted, Sipplauncher uses pre-defined location <testsuite_folder>/TEMPLATES . If there is no folder at this location, templates aren't used. In the embedded mock test suite , the template folder is sipplauncher/tmp-testsuite/TEMPLATES .","title":"Templates"},{"location":"user_guide/#command-line-arguments","text":"Run this to see all available arguments: sipplauncher -h","title":"Command-line arguments"},{"location":"user_guide/#mandatory-arguments","text":"argument name argument value description --dut DUT Device under test IP address --testsuite TESTSUITE Path to a Test suite . Default: <current_working_directory>/tmp-testsuite .","title":"Mandatory arguments"},{"location":"user_guide/#optional-arguments","text":"argument name argument value description -h, --help Show help message and exit --template-folder TEMPLATE_FOLDER Path to a folder with templates . Default: <testsuite>/TEMPLATES . --pattern-exclude PATTERN_EXCLUDE Regular expression to exclude tests. If used with --pattern-only arg, and a test name matches both, the test is excluded. Example: --pattern-exclude options --pattern-exclude '.*_dns' --pattern-exclude '.*_tls' . --pattern-only PATTERN_ONLY Regular expression to specify the only tests which should be run. If used with --pattern-exclude arg, and a test name matches both, the test is excluded. Example: --pattern-only options --pattern-only '.*_dns' --pattern-only '.*_tls' . --network-mask NETWORK_MASK Network mask, which is used for Dynamic IP address assignment . Default: 24 . --group GROUP Number of SIPp tests to be run at the same time. Default: 1 . Please see the example . --group-pause GROUP_PAUSE Pause between group executions. Default: 0.8 . --group-stop-first-fail Stops after any test of the group fails. --random Selects randomly tests from the test pool (instead of alphabetical consecutive ordering). --loop Repeat tests in an endless loop (until interrupted by CTRL+C). It could be used together with group-stop-first-fail arg in order to repeat some test endlessly until it fails, to reproduce some rare issue. --dry-run Dry run, simulates an execution without actual SIPp scenarios launch. --fail-expected OK if the execution fails. --leave-temp Don't remove test run folder after the test has finished. By default, a test run folder is removed after the test has finished. --keyword-replacement-values KEYWORD_REPLACEMENT_VALUES Custom keyword values in JSON object format to be used by the Template engine to replace values in Templated files . Example: --keyword-replacement-values '{ \"ua1_username\": \"test1\", \"ua2_username\": \"test2\", \"some_url\": \"http://10.22.22.24:8080\" }' . --no-pcap Disable capturing to pcap files. --tls-ca-root-cert TLS_CA_ROOT_CERT TLS CA root certificate file (.pem format). It must be used together with tls-ca-root-key arg. --tls-ca-root-key TLS_CA_ROOT_KEY TLS CA root key file (.pem format). It must be used together with tls-ca-root-key arg. --sipp-transport One of: u1, un, ui, t1, tn, l1, ln SIPp -t param. The default is l1 , if TLS usage is auto-detected. Otherwise, it's u1 . TLS usage is auto-detected if any tls-related option is used. --sipp-info-file SIPP_INFO_FILE SIPp -inf argument. Used to specify an Injection file . --sipp-call-rate SIPP_CALL_RATE Calls per seconds, SIPp -r param. Be aware, that --sipp-concurrent-calls-limit could be hit before call rate. --sipp-max-calls SIPP_MAX_CALLS Amount of calls to perform. SIPp -m argument. --sipp-recv-timeout SIPP_RECV_TIMEOUT SIPp -recv_timeout argument. --sipp-tls-version One of: 1.0, 1.1, 1.2 SIPp -tls_version argument. Please see TLS . --sipp-concurrent-calls-limit Number Maximum number of simultaneous calls. Default: 1. SIPp -l param. --default_behaviors DEFAULT_BEHAVIORS SIPp -default_behaviors argument. --global-test-folder GLOBAL_TEST_FOLDER Path to the folder which contains global provisioning or checking scripts. Default: GLOBAL .","title":"Optional arguments"},{"location":"user_guide/#common-usage-examples","text":"","title":"Common usage examples"},{"location":"user_guide/#run-all-tests-consecutively","text":"sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite>","title":"Run all tests consecutively"},{"location":"user_guide/#run-all-tests-with-concurrent-grouping-by-3-tests","text":"Split all tests into concurrent groups of 3 tests in each group. Next, run all groups consecutively. 3 tests inside a group are run concurrently. sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --group 3","title":"Run all tests with concurrent grouping by 3 tests"},{"location":"user_guide/#run-a-single-test","text":"Let's assume, test suite contains a test named normal-0000 . To run only this test: sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --pattern-only normal-0000","title":"Run a single test"},{"location":"user_guide/#run-a-single-test-concurrently-sipp-concurrency","text":"Let's assume, test suite contains a test named normal-0000 . To run this test concurrently in the scope of a single sipplauncher test run (utilising SIPp's capability to generate multiple calls from a single test definition): sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --pattern-only normal-0000 --sipp-max-calls 3 --sipp-call-rate 3 --sipp-concurrent-calls-limit 3","title":"Run a single test concurrently (SIPp concurrency)"},{"location":"user_guide/#run-a-single-test-concurrently-sipplauncher-concurrency","text":"Let's assume, test suite contains a test named normal-0000 . To run this test concurrently as number of unique sipplauncher test runs: sipplauncher --dut 10 .22.22.24 --testsuite <path_to_testsuite> --pattern-only normal-0000 --group 3 --total 3","title":"Run a single test concurrently (sipplauncher concurrency)"},{"location":"user_guide/#test-run-folder","text":"Before executing a test, Sipplauncher copies its content to a temporary test folder. Default location of test run folder is /var/tmp/sipplauncher/<test_name>/<test_run_id> . test_name matches test folder name from Test suite folder layout . test_run_id is assigned dynamically for each test run and is seen in test result output . Then Sipplauncher replaces keywords in the Templated files . Then Sipplauncher launches SIPp instances in the working directory of a Test run folder . After the test has finished, Test run folder contains: scripts and SIPp scenarios , which were run during the test DNS zone description file , which was served by the Embedded DNS server all log files generated TLS certificates, private keys and session keys pcap file By default, the Test run folder is deleted after the test has finished. To change this behavior, please use --leave-temp command-line argument.","title":"Test run folder"},{"location":"user_guide/#template-engine","text":"Sipplauncher uses Jinja2 as a template engine. Therefore, you can use Jinja2 syntax when defining the Templated files . A good example of the approach can be found in the embedded mock test suite . Templates could be placed either into a Test folder or in the Templates folder. Both these locations are searched when Jinja2 imports a template into a test.","title":"Template engine"},{"location":"user_guide/#templated-files","text":"The Template engine processes the following files: scripts SIPp scenarios DNS zone description file","title":"Templated files"},{"location":"user_guide/#keyword-replacement","text":"The Template engine is also responsible for replacing keywords in the Templated files . Keywords could be either internal or supplied using --keyword-replacement-values command-line argument. To define a keyword in a script or SIPp scenario , you should use {{ '{{' }}keyword{{ '}}' }} syntax.","title":"Keyword replacement"},{"location":"user_guide/#internal-keywords","text":"keyword desription dut.host the value, passed via --dut command-line argument. test.name the Test subfolder name. test.run_id the Test random run ID (size 6). test.run_id_number another random id (size 12) composed only of integers/digits. ua[0-9].host Dynamically assigned IP address for the test's SIPp instance ua[0-9] .","title":"Internal keywords"},{"location":"user_guide/#dynamic-ip-address-assignment","text":"Sipplauncher assigns random IP addresses from a DUT IP network before running each test. Sipplauncher takes a DUT IP address, which is supplied via --dut command-line argument. Then it applies a network mask, which is supplied via --network-mask command-line argument, to the DUT IP address. The result is considered the DUT network. Then Sipplauncher randomly allocates IP addresses from the DUT network. The allocated address is then checked to be not yet assigned to another machine in the same LAN. Then the address is assigned to a machine, which runs Sipplauncher. The number of assigned IP addresses corresponds to the number of SIPp scenarios in a test . After the test has finished, the allocated IP addresses are deleted.","title":"Dynamic IP address assignment"},{"location":"user_guide/#embedded-dns-server","text":"Sipplauncher has the DNS server inside. This makes possible to mock DNS names resolution for a DUT. Thus, if requested, Sipplauncher adds dynamically assigned IP addresses to the embedded DNS server. And then SIPp scenarios might use domain names instead of IP addresses. This allows testing how a DUT works with regards to the DNS name resolution. Of course, the DUT should be configured to use Sipplauncher's DNS service instead of regular DNS servers. Usually, this requires patching the DUT's /etc/resolve.conf like this: search example.com nameserver 10 .22.22.22 Here 10.22.22.22 - is the IP address of Sipplauncher's VM. Sipplauncher launches the DNS service on UDP port 53 , if at least one Test has DNS zone description file in it. When a Test is prepared , a DNS zone description file is added to the DNS server. When a Test is cleaned , a DNS zone description file is removed from the DNS server. The DNS server has only a single instance. It's shared among all the Tests . Therefore, to support concurrent test execution (see --group command-line argument), tests should avoid defining overlapping DNS zone information. For example, TestA defines such entry in its dns.txt : ep1.example.com A {{ '{{' }}ua1.host{{ '}}' }} And TestB defines the same entry in its dns.txt : ep1.example.com A {{ '{{' }}ua2.host{{ '}}' }} Then a single DNS server instance will be configured this way: ep1.example.com A 10.22.22.123 ep1.example.com A 10.22.22.210 Therefore, information for ep1.example.com is overlapping. This will cause undefined behavior when a DUT attempts to resolve ep1.example.com . Note The same issue will occur if TestB defines an entry in its dns.txt this way: ep1.example.com A {{ '{{' }}ua1.host{{ '}}' }} Due to the Dynamic IP address assignment , {{ '{{' }}ua1.host{{ '}}' }} will be replaced with different IP addresses for TestA and TestB. And thus the collision will occur.","title":"Embedded DNS server"},{"location":"user_guide/#tls","text":"Sipplauncher supports SIP TLS endpoints. For TLS to work on a UAS SIP endpoint, SSL certificate and private key should be provided to a UAS instance. Sipplauncher by default generates ephemeral SSL certificate and private key for each UAS. And launches UAS using this SSL certificate and private key. However, in this case, security issues regarding using certificates, issued by not-trusted CA, are likely to arise on a DUT UAC side, when the DUT as UAC tries to connect to such a UAS. To overcome this issue, --tls-ca-root-cert and --tls-ca-root-key Sipplauncher arguments could be handy. If these arguments were provided, Sipplauncher signs a generated SSL certificate and private key with supplied CA root certificate and private key. A DUT should be configured to trust this CA. Then a connection is established without security issues. The generated SSL certificates and private keys are saved to a Test run folder . TLS packet exchange is stored in a .pcap file and could be decrypted .","title":"TLS"},{"location":"user_guide/#pcap-capturing","text":"By default, Sipplauncher captures all packets, which have dynamically assigned IP addresses as either src or dst . Packet exchange is captured into a .pcap file, which could be opened with the Wireshark application. Pcap file is named sipp-<test_run_id>.pcap and is stored in a Test run folder . You can disable Pcap capturing with --no-pcap command-line argument.","title":"Pcap capturing"},{"location":"user_guide/#decrypting-tls-traffic","text":"Usually, it's easy to decrypt SSL packet exchange, if you have SSL private key. However, this is not the case for the Diffie-Hellman encryption algorithm. This algorithm uses per-session dynamic keys. Sipplauncher helps to decrypt even Diffie-Hellman-encoded packet exchange. For this, Sipplauncher logs per-session dynamic keys into tls_premaster_keys.txt file in a Test run folder . Then this file could be used to decrypt the packet exchange in Wireshark. You can go to Edit \u2192 Preferences \u2192 Protocols \u2192 SSL and choose tls_premaster_keys.txt in (Pre)-Master-Secret log filename field: Wireshark SSL preferences To enable this feature, you should install Sipplauncher from the source .","title":"Decrypting TLS traffic"},{"location":"user_guide/#log-files","text":"Logging facility is controlled via /usr/local/etc/sipplauncher/sipplauncher.configlog.conf . By default, Sipplauncher logs to following files: /tmp/sipplauncher.log - general log file. /var/tmp/sipplauncher/<test_name>/<test_run_id>/sipplauncher.log - log, that contains information regarding execution of test test_name . /var/tmp/sipplauncher/<test_name>/<test_run_id>/pysipp.launch.log - log, that contains information regarding running SIPp instances of test test_name . /var/tmp/sipplauncher/<test_name>/<test_run_id>/tls_premaster_keys.txt - log of captured TLS Pre-master keys . /var/tmp/sipplauncher/<test_name>/<test_run_id>/ua[0-9].. - varios SIPp scenario ua[0-9] logs, which were produced by SIPp.","title":"Log files"}]}